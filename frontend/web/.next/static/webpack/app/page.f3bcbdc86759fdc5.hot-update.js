"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/useChartStore.ts":
/*!********************************!*\
  !*** ./store/useChartStore.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChartStore: function() { return /* binding */ useChartStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n\n\nconst useChartStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        symbol: \"AIAUSDT\",\n        timeframe: \"15m\",\n        strategies: [\n            \"rule\",\n            \"ml\",\n            \"trend_continuation\",\n            \"sweep_reversal\",\n            \"volatility_breakout\"\n        ],\n        selectedStrategy: \"rule\",\n        backtests: [],\n        selectedRunId: null,\n        trades: [],\n        selectedTradeId: null,\n        bars: [],\n        meta: null,\n        summary: null,\n        liveStatus: null,\n        isLiveLoading: false,\n        liveError: null,\n        isRunningBacktest: false,\n        lastError: null,\n        lastRunId: undefined,\n        overlays: {\n            showRuleSignals: true,\n            showMicrostructure: false,\n            showMarketStructure: false,\n            showMLProba: false\n        },\n        loading: false,\n        error: null,\n        setSymbol: (symbol)=>set({\n                symbol\n            }),\n        setTimeframe: (timeframe)=>set({\n                timeframe\n            }),\n        setSelectedStrategy: (strategy)=>set({\n                selectedStrategy: strategy\n            }),\n        setBacktests: (runs)=>set({\n                backtests: runs\n            }),\n        setSelectedRunId: (runId)=>set({\n                selectedRunId: runId\n            }),\n        setTrades: (trades)=>set({\n                trades: [\n                    ...trades\n                ].sort((a, b)=>{\n                    const parse = (t)=>t ? new Date(t).getTime() : 0;\n                    var _a_entry_time, _ref;\n                    const ta = parse((_ref = (_a_entry_time = a.entry_time) !== null && _a_entry_time !== void 0 ? _a_entry_time : a.timestamp) !== null && _ref !== void 0 ? _ref : null);\n                    var _b_entry_time, _ref1;\n                    const tb = parse((_ref1 = (_b_entry_time = b.entry_time) !== null && _b_entry_time !== void 0 ? _b_entry_time : b.timestamp) !== null && _ref1 !== void 0 ? _ref1 : null);\n                    return ta - tb;\n                })\n            }),\n        setSelectedTradeId: (tradeId)=>set({\n                selectedTradeId: tradeId\n            }),\n        setBars: (bars)=>set({\n                bars\n            }),\n        setMeta: (meta)=>set({\n                meta\n            }),\n        setSummary: (summary)=>set({\n                summary\n            }),\n        setOverlays: (partial)=>set((state)=>({\n                    overlays: {\n                        ...state.overlays,\n                        ...partial\n                    }\n                })),\n        setLoading: (loading)=>set({\n                loading\n            }),\n        setError: (error)=>set({\n                error\n            }),\n        setLiveStatus: (liveStatus)=>set({\n                liveStatus\n            }),\n        setIsLiveLoading: (flag)=>set({\n                isLiveLoading: flag\n            }),\n        setLiveError: (msg)=>set({\n                liveError: msg\n            }),\n        setLastRunId: (id)=>set({\n                lastRunId: id\n            }),\n        runBacktest: async ()=>{\n            const { symbol, timeframe, selectedStrategy } = get();\n            set({\n                isRunningBacktest: true,\n                lastError: null\n            });\n            try {\n                const res = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_0__.runBacktest)({\n                    symbol,\n                    timeframe,\n                    strategy: selectedStrategy\n                });\n                set({\n                    selectedRunId: res.run_id\n                });\n                const runs = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_0__.fetchBacktests)(symbol, timeframe, selectedStrategy);\n                set({\n                    backtests: runs\n                });\n                const { bars, meta } = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_0__.fetchChart)(symbol, timeframe, res.run_id);\n                set({\n                    bars,\n                    meta\n                });\n                const trades = await (0,_lib_api__WEBPACK_IMPORTED_MODULE_0__.fetchTrades)(res.run_id);\n                set({\n                    trades\n                });\n            } catch (err) {\n                var _err_response_data, _err_response;\n                var _err_response_data_detail, _ref;\n                const detail = (_ref = (_err_response_data_detail = err === null || err === void 0 ? void 0 : (_err_response = err.response) === null || _err_response === void 0 ? void 0 : (_err_response_data = _err_response.data) === null || _err_response_data === void 0 ? void 0 : _err_response_data.detail) !== null && _err_response_data_detail !== void 0 ? _err_response_data_detail : err === null || err === void 0 ? void 0 : err.message) !== null && _ref !== void 0 ? _ref : \"Backtest failed\";\n                set({\n                    lastError: detail\n                });\n            } finally{\n                set({\n                    isRunningBacktest: false\n                });\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL3VzZUNoYXJ0U3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlDO0FBT2Q7QUFrSVosTUFBTU0sZ0JBQWdCTiwrQ0FBTUEsQ0FBYSxDQUFDTyxLQUFLQyxNQUFTO1FBQzdEQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsWUFBWTtZQUFDO1lBQVE7WUFBTTtZQUFzQjtZQUFrQjtTQUFzQjtRQUN6RkMsa0JBQWtCO1FBQ2xCQyxXQUFXLEVBQUU7UUFDYkMsZUFBZTtRQUNmQyxRQUFRLEVBQUU7UUFDVkMsaUJBQWlCO1FBQ2pCQyxNQUFNLEVBQUU7UUFDUkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RDLFlBQVk7UUFDWkMsZUFBZTtRQUNmQyxXQUFXO1FBQ1hDLG1CQUFtQjtRQUNuQkMsV0FBVztRQUNYQyxXQUFXQztRQUNYQyxVQUFVO1lBQ1JDLGlCQUFpQjtZQUNqQkMsb0JBQW9CO1lBQ3BCQyxxQkFBcUI7WUFDckJDLGFBQWE7UUFDZjtRQUNBQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsV0FBVyxDQUFDekIsU0FBV0YsSUFBSTtnQkFBRUU7WUFBTztRQUNwQzBCLGNBQWMsQ0FBQ3pCLFlBQWNILElBQUk7Z0JBQUVHO1lBQVU7UUFDN0MwQixxQkFBcUIsQ0FBQ0MsV0FBYTlCLElBQUk7Z0JBQUVLLGtCQUFrQnlCO1lBQVM7UUFDcEVDLGNBQWMsQ0FBQ0MsT0FBU2hDLElBQUk7Z0JBQUVNLFdBQVcwQjtZQUFLO1FBQzlDQyxrQkFBa0IsQ0FBQ0MsUUFBVWxDLElBQUk7Z0JBQUVPLGVBQWUyQjtZQUFNO1FBQ3hEQyxXQUFXLENBQUMzQixTQUNWUixJQUFJO2dCQUNGUSxRQUFRO3VCQUFJQTtpQkFBTyxDQUFDNEIsSUFBSSxDQUFDLENBQUNDLEdBQUdDO29CQUMzQixNQUFNQyxRQUFRLENBQUNDLElBQ2JBLElBQUksSUFBSUMsS0FBS0QsR0FBR0UsT0FBTyxLQUFLO3dCQUNiTCxlQUFBQTtvQkFBakIsTUFBTU0sS0FBS0osTUFBTUYsQ0FBQUEsT0FBQUEsQ0FBQUEsZ0JBQUFBLEVBQUVPLFVBQVUsY0FBWlAsMkJBQUFBLGdCQUFnQixFQUFXUSxTQUFTLGNBQXBDUixrQkFBQUEsT0FBd0M7d0JBQ3hDQyxlQUFBQTtvQkFBakIsTUFBTVEsS0FBS1AsTUFBTUQsQ0FBQUEsUUFBQUEsQ0FBQUEsZ0JBQUFBLEVBQUVNLFVBQVUsY0FBWk4sMkJBQUFBLGdCQUFnQixFQUFXTyxTQUFTLGNBQXBDUCxtQkFBQUEsUUFBd0M7b0JBQ3pELE9BQU9LLEtBQUtHO2dCQUNkO1lBQ0Y7UUFDRkMsb0JBQW9CLENBQUNDLFVBQVloRCxJQUFJO2dCQUFFUyxpQkFBaUJ1QztZQUFRO1FBQ2hFQyxTQUFTLENBQUN2QyxPQUFTVixJQUFJO2dCQUFFVTtZQUFLO1FBQzlCd0MsU0FBUyxDQUFDdkMsT0FBU1gsSUFBSTtnQkFBRVc7WUFBSztRQUM5QndDLFlBQVksQ0FBQ3ZDLFVBQVlaLElBQUk7Z0JBQUVZO1lBQVE7UUFDdkN3QyxhQUFhLENBQUNDLFVBQ1pyRCxJQUFJLENBQUNzRCxRQUFXO29CQUFFbEMsVUFBVTt3QkFBRSxHQUFHa0MsTUFBTWxDLFFBQVE7d0JBQUUsR0FBR2lDLE9BQU87b0JBQUM7Z0JBQUU7UUFDaEVFLFlBQVksQ0FBQzlCLFVBQVl6QixJQUFJO2dCQUFFeUI7WUFBUTtRQUN2QytCLFVBQVUsQ0FBQzlCLFFBQVUxQixJQUFJO2dCQUFFMEI7WUFBTTtRQUNqQytCLGVBQWUsQ0FBQzVDLGFBQWViLElBQUk7Z0JBQUVhO1lBQVc7UUFDaEQ2QyxrQkFBa0IsQ0FBQ0MsT0FBUzNELElBQUk7Z0JBQUVjLGVBQWU2QztZQUFLO1FBQ3REQyxjQUFjLENBQUNDLE1BQVE3RCxJQUFJO2dCQUFFZSxXQUFXOEM7WUFBSTtRQUM1Q0MsY0FBYyxDQUFDQyxLQUFPL0QsSUFBSTtnQkFBRWtCLFdBQVc2QztZQUFHO1FBQzFDbEUsYUFBYTtZQUNYLE1BQU0sRUFBRUssTUFBTSxFQUFFQyxTQUFTLEVBQUVFLGdCQUFnQixFQUFFLEdBQUdKO1lBQ2hERCxJQUFJO2dCQUFFZ0IsbUJBQW1CO2dCQUFNQyxXQUFXO1lBQUs7WUFDL0MsSUFBSTtnQkFDRixNQUFNK0MsTUFBTSxNQUFNbEUscURBQWNBLENBQUM7b0JBQy9CSTtvQkFDQUM7b0JBQ0EyQixVQUFVekI7Z0JBQ1o7Z0JBQ0FMLElBQUk7b0JBQUVPLGVBQWV5RCxJQUFJQyxNQUFNO2dCQUFDO2dCQUVoQyxNQUFNakMsT0FBTyxNQUFNdEMsd0RBQWNBLENBQUNRLFFBQVFDLFdBQVdFO2dCQUNyREwsSUFBSTtvQkFBRU0sV0FBVzBCO2dCQUFLO2dCQUV0QixNQUFNLEVBQUV0QixJQUFJLEVBQUVDLElBQUksRUFBRSxHQUFHLE1BQU1oQixvREFBVUEsQ0FBQ08sUUFBUUMsV0FBVzZELElBQUlDLE1BQU07Z0JBQ3JFakUsSUFBSTtvQkFBRVU7b0JBQU1DO2dCQUFLO2dCQUVqQixNQUFNSCxTQUFTLE1BQU1aLHFEQUFXQSxDQUFDb0UsSUFBSUMsTUFBTTtnQkFDM0NqRSxJQUFJO29CQUFFUTtnQkFBTztZQUNmLEVBQUUsT0FBTzBELEtBQVU7b0JBRWZBLG9CQUFBQTtvQkFBQUEsMkJBQUFBO2dCQURGLE1BQU1DLFNBQ0pELENBQUFBLE9BQUFBLENBQUFBLDRCQUFBQSxnQkFBQUEsMkJBQUFBLGdCQUFBQSxJQUFLRSxRQUFRLGNBQWJGLHFDQUFBQSxxQkFBQUEsY0FBZUcsSUFBSSxjQUFuQkgseUNBQUFBLG1CQUFxQkMsTUFBTSxjQUEzQkQsdUNBQUFBLDRCQUErQkEsZ0JBQUFBLDBCQUFBQSxJQUFLSSxPQUFPLGNBQTNDSixrQkFBQUEsT0FBK0M7Z0JBQ2pEbEUsSUFBSTtvQkFBRWlCLFdBQVdrRDtnQkFBTztZQUMxQixTQUFVO2dCQUNSbkUsSUFBSTtvQkFBRWdCLG1CQUFtQjtnQkFBTTtZQUNqQztRQUNGO0lBQ0YsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdG9yZS91c2VDaGFydFN0b3JlLnRzP2U2MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSBcInp1c3RhbmRcIjtcblxuaW1wb3J0IHtcbiAgZmV0Y2hCYWNrdGVzdHMsXG4gIGZldGNoQ2hhcnQsXG4gIGZldGNoVHJhZGVzLFxuICBydW5CYWNrdGVzdCBhcyBydW5CYWNrdGVzdEFwaSxcbn0gZnJvbSBcIkAvbGliL2FwaVwiO1xuXG5leHBvcnQgdHlwZSBCYXJQb2ludCA9IHtcbiAgdGltZTogbnVtYmVyO1xuICBvcGVuOiBudW1iZXI7XG4gIGhpZ2g6IG51bWJlcjtcbiAgbG93OiBudW1iZXI7XG4gIGNsb3NlOiBudW1iZXI7XG4gIHZvbHVtZT86IG51bWJlcjtcbiAgcnVsZV9lbnRyeT86IG51bWJlcjtcbiAgcnVsZV9leGl0PzogbnVtYmVyO1xuICBtbF9sb25nX3Byb2JhPzogbnVtYmVyO1xuICBtc190cmVuZD86IG51bWJlcjtcbiAgbXNfY2hvcD86IG51bWJlcjtcbiAgbXNfaGhfbGxfdHJlbmQ/OiBudW1iZXI7XG4gIGZ2Z191cD86IG51bWJlcjtcbiAgZnZnX2Rvd24/OiBudW1iZXI7XG4gIHRyYWRlX2VudHJpZXM/OiBzdHJpbmdbXTtcbiAgdHJhZGVfZXhpdHM/OiBzdHJpbmdbXTtcbn07XG5cbmV4cG9ydCB0eXBlIENoYXJ0TWV0YSA9IHtcbiAgcGlwZWxpbmVfdmVyc2lvbj86IHN0cmluZztcbiAgZmVhdHVyZXNfcHJlc2V0Pzogc3RyaW5nO1xuICBsYXN0X3VwZGF0ZWQ/OiBzdHJpbmc7XG4gIHJ1bl9pZD86IHN0cmluZyB8IG51bGw7XG4gIHN0cmF0ZWd5Pzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIFN1bW1hcnlTdGF0cyA9IHtcbiAgZmluYWxfZXF1aXR5PzogbnVtYmVyO1xuICBjdW1fcmV0dXJuPzogbnVtYmVyO1xuICB0cmFkZV9jb3VudD86IG51bWJlcjtcbiAgd2luX3JhdGU/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBCYWNrdGVzdFJ1bkluZm8gPSB7XG4gIHJ1bl9pZDogc3RyaW5nO1xuICBzdHJhdGVneTogc3RyaW5nO1xuICBzeW1ib2w6IHN0cmluZztcbiAgdGltZWZyYW1lOiBzdHJpbmc7XG4gIHN0YXJ0Pzogc3RyaW5nIHwgbnVsbDtcbiAgZW5kPzogc3RyaW5nIHwgbnVsbDtcbiAgbWV0cmljczogUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgbnVsbD47XG59O1xuXG5leHBvcnQgdHlwZSBUcmFkZVJvdyA9IHtcbiAgdHJhZGVfaWQ6IHN0cmluZztcbiAgZW50cnlfdGltZTogc3RyaW5nO1xuICBleGl0X3RpbWU/OiBzdHJpbmcgfCBudWxsO1xuICBzaWRlOiBzdHJpbmc7XG4gIHF0eTogbnVtYmVyO1xuICBlbnRyeV9wcmljZTogbnVtYmVyO1xuICBleGl0X3ByaWNlPzogbnVtYmVyIHwgbnVsbDtcbiAgcG5sPzogbnVtYmVyIHwgbnVsbDtcbiAgcmVhc29uPzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIExpdmVQb3NpdGlvbiA9IHtcbiAgaWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHNpZGU6IHN0cmluZztcbiAgcXR5OiBudW1iZXI7XG4gIGVudHJ5X3ByaWNlOiBudW1iZXI7XG4gIGN1cnJlbnRfcHJpY2U/OiBudW1iZXIgfCBudWxsO1xuICBwbmw/OiBudW1iZXIgfCBudWxsO1xuICBlbnRyeV90aW1lPzogc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIExpdmVTdGF0dXMgPSB7XG4gIHJ1bl9pZDogc3RyaW5nO1xuICBzeW1ib2w6IHN0cmluZztcbiAgdGltZWZyYW1lOiBzdHJpbmc7XG4gIHN0cmF0ZWd5OiBzdHJpbmc7XG4gIHN0YXJ0X3RpbWU/OiBzdHJpbmcgfCBudWxsO1xuICBsYXN0X2Jhcl90aW1lPzogc3RyaW5nIHwgbnVsbDtcbiAgZXF1aXR5OiBudW1iZXI7XG4gIHJlYWxpemVkX3BubD86IG51bWJlciB8IG51bGw7XG4gIHVucmVhbGl6ZWRfcG5sPzogbnVtYmVyIHwgbnVsbDtcbiAgZGFpbHlfcmVhbGl6ZWRfcG5sPzogbnVtYmVyIHwgbnVsbDtcbiAgb3Blbl9wb3NpdGlvbnM6IExpdmVQb3NpdGlvbltdO1xuICByaXNrX3N0YXRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufTtcblxudHlwZSBDaGFydFN0YXRlID0ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgdGltZWZyYW1lOiBzdHJpbmc7XG4gIHN0cmF0ZWdpZXM6IHN0cmluZ1tdO1xuICBzZWxlY3RlZFN0cmF0ZWd5OiBzdHJpbmc7XG4gIGJhY2t0ZXN0czogQmFja3Rlc3RSdW5JbmZvW107XG4gIHNlbGVjdGVkUnVuSWQ6IHN0cmluZyB8IG51bGw7XG4gIHRyYWRlczogVHJhZGVSb3dbXTtcbiAgc2VsZWN0ZWRUcmFkZUlkOiBzdHJpbmcgfCBudWxsO1xuICBiYXJzOiBCYXJQb2ludFtdO1xuICBtZXRhOiBDaGFydE1ldGEgfCBudWxsO1xuICBzdW1tYXJ5OiBTdW1tYXJ5U3RhdHMgfCBudWxsO1xuICBsaXZlU3RhdHVzOiBMaXZlU3RhdHVzIHwgbnVsbDtcbiAgaXNMaXZlTG9hZGluZzogYm9vbGVhbjtcbiAgbGl2ZUVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBpc1J1bm5pbmdCYWNrdGVzdDogYm9vbGVhbjtcbiAgbGFzdEVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBsYXN0UnVuSWQ/OiBzdHJpbmc7XG4gIG92ZXJsYXlzOiB7XG4gICAgc2hvd1J1bGVTaWduYWxzOiBib29sZWFuO1xuICAgIHNob3dNaWNyb3N0cnVjdHVyZTogYm9vbGVhbjtcbiAgICBzaG93TWFya2V0U3RydWN0dXJlOiBib29sZWFuO1xuICAgIHNob3dNTFByb2JhOiBib29sZWFuO1xuICB9O1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgc2V0U3ltYm9sOiAoc3ltYm9sOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldFRpbWVmcmFtZTogKHRmOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkU3RyYXRlZ3k6IChzdHJhdGVneTogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRCYWNrdGVzdHM6IChydW5zOiBCYWNrdGVzdFJ1bkluZm9bXSkgPT4gdm9pZDtcbiAgc2V0U2VsZWN0ZWRSdW5JZDogKHJ1bklkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRUcmFkZXM6ICh0cmFkZXM6IFRyYWRlUm93W10pID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkVHJhZGVJZDogKHRyYWRlSWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEJhcnM6IChiYXJzOiBCYXJQb2ludFtdKSA9PiB2b2lkO1xuICBzZXRNZXRhOiAobWV0YTogQ2hhcnRNZXRhIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0U3VtbWFyeTogKHN1bW1hcnk6IFN1bW1hcnlTdGF0cyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldE92ZXJsYXlzOiAocGFydGlhbDogUGFydGlhbDxDaGFydFN0YXRlW1wib3ZlcmxheXNcIl0+KSA9PiB2b2lkO1xuICBzZXRMb2FkaW5nOiAobG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RXJyb3I6IChtc2c6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldExpdmVTdGF0dXM6IChzdGF0dXM6IExpdmVTdGF0dXMgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRJc0xpdmVMb2FkaW5nOiAoZmxhZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0TGl2ZUVycm9yOiAobXNnOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRMYXN0UnVuSWQ6IChpZD86IHN0cmluZykgPT4gdm9pZDtcbiAgcnVuQmFja3Rlc3Q6ICgpID0+IFByb21pc2U8dm9pZD47XG59O1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhcnRTdG9yZSA9IGNyZWF0ZTxDaGFydFN0YXRlPigoc2V0LCBnZXQpID0+ICh7XG4gIHN5bWJvbDogXCJBSUFVU0RUXCIsXG4gIHRpbWVmcmFtZTogXCIxNW1cIixcbiAgc3RyYXRlZ2llczogW1wicnVsZVwiLCBcIm1sXCIsIFwidHJlbmRfY29udGludWF0aW9uXCIsIFwic3dlZXBfcmV2ZXJzYWxcIiwgXCJ2b2xhdGlsaXR5X2JyZWFrb3V0XCJdLFxuICBzZWxlY3RlZFN0cmF0ZWd5OiBcInJ1bGVcIixcbiAgYmFja3Rlc3RzOiBbXSxcbiAgc2VsZWN0ZWRSdW5JZDogbnVsbCxcbiAgdHJhZGVzOiBbXSxcbiAgc2VsZWN0ZWRUcmFkZUlkOiBudWxsLFxuICBiYXJzOiBbXSxcbiAgbWV0YTogbnVsbCxcbiAgc3VtbWFyeTogbnVsbCxcbiAgbGl2ZVN0YXR1czogbnVsbCxcbiAgaXNMaXZlTG9hZGluZzogZmFsc2UsXG4gIGxpdmVFcnJvcjogbnVsbCxcbiAgaXNSdW5uaW5nQmFja3Rlc3Q6IGZhbHNlLFxuICBsYXN0RXJyb3I6IG51bGwsXG4gIGxhc3RSdW5JZDogdW5kZWZpbmVkLFxuICBvdmVybGF5czoge1xuICAgIHNob3dSdWxlU2lnbmFsczogdHJ1ZSxcbiAgICBzaG93TWljcm9zdHJ1Y3R1cmU6IGZhbHNlLFxuICAgIHNob3dNYXJrZXRTdHJ1Y3R1cmU6IGZhbHNlLFxuICAgIHNob3dNTFByb2JhOiBmYWxzZSxcbiAgfSxcbiAgbG9hZGluZzogZmFsc2UsXG4gIGVycm9yOiBudWxsLFxuICBzZXRTeW1ib2w6IChzeW1ib2wpID0+IHNldCh7IHN5bWJvbCB9KSxcbiAgc2V0VGltZWZyYW1lOiAodGltZWZyYW1lKSA9PiBzZXQoeyB0aW1lZnJhbWUgfSksXG4gIHNldFNlbGVjdGVkU3RyYXRlZ3k6IChzdHJhdGVneSkgPT4gc2V0KHsgc2VsZWN0ZWRTdHJhdGVneTogc3RyYXRlZ3kgfSksXG4gIHNldEJhY2t0ZXN0czogKHJ1bnMpID0+IHNldCh7IGJhY2t0ZXN0czogcnVucyB9KSxcbiAgc2V0U2VsZWN0ZWRSdW5JZDogKHJ1bklkKSA9PiBzZXQoeyBzZWxlY3RlZFJ1bklkOiBydW5JZCB9KSxcbiAgc2V0VHJhZGVzOiAodHJhZGVzKSA9PlxuICAgIHNldCh7XG4gICAgICB0cmFkZXM6IFsuLi50cmFkZXNdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2UgPSAodDogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCkgPT5cbiAgICAgICAgICB0ID8gbmV3IERhdGUodCkuZ2V0VGltZSgpIDogMDtcbiAgICAgICAgY29uc3QgdGEgPSBwYXJzZShhLmVudHJ5X3RpbWUgPz8gKGEgYXMgYW55KS50aW1lc3RhbXAgPz8gbnVsbCk7XG4gICAgICAgIGNvbnN0IHRiID0gcGFyc2UoYi5lbnRyeV90aW1lID8/IChiIGFzIGFueSkudGltZXN0YW1wID8/IG51bGwpO1xuICAgICAgICByZXR1cm4gdGEgLSB0YjtcbiAgICAgIH0pLFxuICAgIH0pLFxuICBzZXRTZWxlY3RlZFRyYWRlSWQ6ICh0cmFkZUlkKSA9PiBzZXQoeyBzZWxlY3RlZFRyYWRlSWQ6IHRyYWRlSWQgfSksXG4gIHNldEJhcnM6IChiYXJzKSA9PiBzZXQoeyBiYXJzIH0pLFxuICBzZXRNZXRhOiAobWV0YSkgPT4gc2V0KHsgbWV0YSB9KSxcbiAgc2V0U3VtbWFyeTogKHN1bW1hcnkpID0+IHNldCh7IHN1bW1hcnkgfSksXG4gIHNldE92ZXJsYXlzOiAocGFydGlhbCkgPT5cbiAgICBzZXQoKHN0YXRlKSA9PiAoeyBvdmVybGF5czogeyAuLi5zdGF0ZS5vdmVybGF5cywgLi4ucGFydGlhbCB9IH0pKSxcbiAgc2V0TG9hZGluZzogKGxvYWRpbmcpID0+IHNldCh7IGxvYWRpbmcgfSksXG4gIHNldEVycm9yOiAoZXJyb3IpID0+IHNldCh7IGVycm9yIH0pLFxuICBzZXRMaXZlU3RhdHVzOiAobGl2ZVN0YXR1cykgPT4gc2V0KHsgbGl2ZVN0YXR1cyB9KSxcbiAgc2V0SXNMaXZlTG9hZGluZzogKGZsYWcpID0+IHNldCh7IGlzTGl2ZUxvYWRpbmc6IGZsYWcgfSksXG4gIHNldExpdmVFcnJvcjogKG1zZykgPT4gc2V0KHsgbGl2ZUVycm9yOiBtc2cgfSksXG4gIHNldExhc3RSdW5JZDogKGlkKSA9PiBzZXQoeyBsYXN0UnVuSWQ6IGlkIH0pLFxuICBydW5CYWNrdGVzdDogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgc3ltYm9sLCB0aW1lZnJhbWUsIHNlbGVjdGVkU3RyYXRlZ3kgfSA9IGdldCgpO1xuICAgIHNldCh7IGlzUnVubmluZ0JhY2t0ZXN0OiB0cnVlLCBsYXN0RXJyb3I6IG51bGwgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJ1bkJhY2t0ZXN0QXBpKHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICB0aW1lZnJhbWUsXG4gICAgICAgIHN0cmF0ZWd5OiBzZWxlY3RlZFN0cmF0ZWd5LFxuICAgICAgfSk7XG4gICAgICBzZXQoeyBzZWxlY3RlZFJ1bklkOiByZXMucnVuX2lkIH0pO1xuXG4gICAgICBjb25zdCBydW5zID0gYXdhaXQgZmV0Y2hCYWNrdGVzdHMoc3ltYm9sLCB0aW1lZnJhbWUsIHNlbGVjdGVkU3RyYXRlZ3kpO1xuICAgICAgc2V0KHsgYmFja3Rlc3RzOiBydW5zIH0pO1xuXG4gICAgICBjb25zdCB7IGJhcnMsIG1ldGEgfSA9IGF3YWl0IGZldGNoQ2hhcnQoc3ltYm9sLCB0aW1lZnJhbWUsIHJlcy5ydW5faWQpO1xuICAgICAgc2V0KHsgYmFycywgbWV0YSB9KTtcblxuICAgICAgY29uc3QgdHJhZGVzID0gYXdhaXQgZmV0Y2hUcmFkZXMocmVzLnJ1bl9pZCk7XG4gICAgICBzZXQoeyB0cmFkZXMgfSk7XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGNvbnN0IGRldGFpbCA9XG4gICAgICAgIGVycj8ucmVzcG9uc2U/LmRhdGE/LmRldGFpbCA/PyBlcnI/Lm1lc3NhZ2UgPz8gXCJCYWNrdGVzdCBmYWlsZWRcIjtcbiAgICAgIHNldCh7IGxhc3RFcnJvcjogZGV0YWlsIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXQoeyBpc1J1bm5pbmdCYWNrdGVzdDogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxufSkpO1xuIl0sIm5hbWVzIjpbImNyZWF0ZSIsImZldGNoQmFja3Rlc3RzIiwiZmV0Y2hDaGFydCIsImZldGNoVHJhZGVzIiwicnVuQmFja3Rlc3QiLCJydW5CYWNrdGVzdEFwaSIsInVzZUNoYXJ0U3RvcmUiLCJzZXQiLCJnZXQiLCJzeW1ib2wiLCJ0aW1lZnJhbWUiLCJzdHJhdGVnaWVzIiwic2VsZWN0ZWRTdHJhdGVneSIsImJhY2t0ZXN0cyIsInNlbGVjdGVkUnVuSWQiLCJ0cmFkZXMiLCJzZWxlY3RlZFRyYWRlSWQiLCJiYXJzIiwibWV0YSIsInN1bW1hcnkiLCJsaXZlU3RhdHVzIiwiaXNMaXZlTG9hZGluZyIsImxpdmVFcnJvciIsImlzUnVubmluZ0JhY2t0ZXN0IiwibGFzdEVycm9yIiwibGFzdFJ1bklkIiwidW5kZWZpbmVkIiwib3ZlcmxheXMiLCJzaG93UnVsZVNpZ25hbHMiLCJzaG93TWljcm9zdHJ1Y3R1cmUiLCJzaG93TWFya2V0U3RydWN0dXJlIiwic2hvd01MUHJvYmEiLCJsb2FkaW5nIiwiZXJyb3IiLCJzZXRTeW1ib2wiLCJzZXRUaW1lZnJhbWUiLCJzZXRTZWxlY3RlZFN0cmF0ZWd5Iiwic3RyYXRlZ3kiLCJzZXRCYWNrdGVzdHMiLCJydW5zIiwic2V0U2VsZWN0ZWRSdW5JZCIsInJ1bklkIiwic2V0VHJhZGVzIiwic29ydCIsImEiLCJiIiwicGFyc2UiLCJ0IiwiRGF0ZSIsImdldFRpbWUiLCJ0YSIsImVudHJ5X3RpbWUiLCJ0aW1lc3RhbXAiLCJ0YiIsInNldFNlbGVjdGVkVHJhZGVJZCIsInRyYWRlSWQiLCJzZXRCYXJzIiwic2V0TWV0YSIsInNldFN1bW1hcnkiLCJzZXRPdmVybGF5cyIsInBhcnRpYWwiLCJzdGF0ZSIsInNldExvYWRpbmciLCJzZXRFcnJvciIsInNldExpdmVTdGF0dXMiLCJzZXRJc0xpdmVMb2FkaW5nIiwiZmxhZyIsInNldExpdmVFcnJvciIsIm1zZyIsInNldExhc3RSdW5JZCIsImlkIiwicmVzIiwicnVuX2lkIiwiZXJyIiwiZGV0YWlsIiwicmVzcG9uc2UiLCJkYXRhIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/useChartStore.ts\n"));

/***/ })

});